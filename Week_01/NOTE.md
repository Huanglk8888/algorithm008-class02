88. 两数之和
    暴力解法：时间复杂度O(n*n)，空间复杂度O(1),耗时57ms，
    优化-空间换时间-使用哈希表
    哈希表解法：时间复杂度O(n),时间复杂度O(n),耗时4ms
    
26. 删除排序数组中的重复项
    双指针解法：时间复杂度O(n),空间复杂度O(1)
    优化-一次遍历 ，代码少
    
    
283. 移动零
       思路：简化成一个循环，只要和index不是同一个位置，移动后就把当前位置变为0
       
66. 加一
       暴力解法
       思路：数组遍历 
            1.末位无进位，则末位加一,末位无进位，前面也不可能进行进位，例如 8 =>9
            2.末位有进位，在中间位置进位停止，则需要找到进位的典型标志, 即为当前位 后为0，则前一位加1，直到不为0为止，例如 299=>300
            3.末位有进位，并且一直进位到最前方导致结果多出一位，对于这种情况，需要在第2种情况遍历结束的基础上，进行单独处理 99=>100

88. 合并两个有序数组
        最简单的解法:将两个数组合并之后再排序,时间复杂度较差，为O((n+m)log(n+m)),空间复杂度O(1)
        思路；从后向前数组遍历
              两个数组从后面元素往前比较，大的元素放到nums1尾部，然后再向前挪
              时间复杂度：O(m+n)O(m+n)
              
21. 合并两个有序链表
        解法：递归
        思路：1.如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理；
              2.终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束；
              3.返回值：每一层调用都返回排序好的链表头
               O(m+n)，mm 为 l1的长度，nn 为 l2 的长度
               
641. 设计循环双端队列
       思路：修改循环队列
       
189. 旋转数组
        暴力解法：时间复杂度：O(n*k)O(n∗k) 。每个元素都被移动 1 步（O(n)O(n)） k次（O(k)O(k)。
                  空间复杂度：O(1)O(1) 。没有额外空间被使用。
        数组反转：思路：旋转将后面的元素放置到前面，前面的元素放置到后面。如果翻转数组可以到达这个目的，但是旋转到数组前面的元素与向后移动的元素，这两个分组内的元素顺序也翻转了。那么再将他们翻转过来即可
               2种解法内存消耗差不多，但是数组反转的执行时间大大快于暴力解法